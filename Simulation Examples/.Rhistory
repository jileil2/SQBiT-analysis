require('mgcv')
?gam
15 / 0.7
9.7 + 15.2 + 10 + 11.2 + 11
library('devtools')
install_github('First-Data-Lab/BPST')
install_github('FIRST-Data-Lab/BPST')
install_github('/FIRST-Data-Lab/BPST', )
install_github('FIRST-Data-Lab/BPST', force = TRUE)
install_github('FIRST-Data-Lab/Triangulation')
install_github('FIRST-Data-Lab/Triangulation', force = TRUE)
?predict
34 /55
y <- x + 2 * z + rnorm(100)
x <- rnorm(100)
z <- rnorm(100)
y <- x + 2 * z + rnorm(100)
lmod <- lm(y ~ x)
lmod2 <- lm(y ~ x + z)
anova(lmod2)
anova(lmod2, lmod)
anova(lmod, lmod2)
pf(265.81, 1, 97)
1-pf(265.81, 1, 97)
358.76 / (130.92 / 97)
qf(.95, 2, 17)
qf(.95, 2, 16)
?rbinom
rG <- function(n, tau) {
Is <- rbinom(n, size = 1, prob = tau)
Is * (- 2 * tau) + 2 * (1 - tau) * (1 - Is)
}
require('quantreg')
65.86 / 48.02
69.39 / 47.86
249.30 / 174.64
285.39 / 183.42
(1555 - 1456) / 5
(1555 - 1357) / 5
1113 / 928
colorRamps::matlab.like(100)
dbinom(x = 1, 3, prob = 0.28)
dbinom(x = 1, 3, prob = 0.18)
dbinom(x = 1, 3, prob = 0.18)
dbinom(x = 2, 3, prob = 0.18)
dbinom(x = 2, 3, prob = 0.28)
dbinom(x = 3, 3, prob = 0.28)
dbinom(x = 3, 3, prob = 0.18)
dbinom(x = 1, 3, prob = 0.30.5)
dbinom(x = 1, 3, prob = 0.305)
dbinom(x = 2, 3, prob = 0.305)
dbinom(x = 3, 3, prob = 0.305)
6 + 4 + 4 + 4 + 4 + 4 + 12 + 6
4 + 4 + 4 + 4 + 4 + 4 + 12 + 6
25 - sqrt(2) * 12.5
25 + sqrt(2) * 12.5
sum(1/factorial(t))
t = 1:250
sum(1/factorial(t))
x <- c(.12, .10, .15)
-3/sum(log(x))
1/16
1/9
3/48
x <- c(14.2, 5.6, 20.5, 12.8)
prod(x)
14.2 * 5.6 * 20.5 * 12.8
14.2 * 5.6 * 20.5 * 12.8 * 2^4
max(x)
500000000 / 1000
d = 3
(d+1)^2/(2* (d+2))- (d+1)/2
(10270 + 6698 + 5135 + 4464) / (31943 + 17958 + 12145 + 9531)
(8484+10270 + 6698 + 5135 + 4464) / (33124+31943 + 17958 + 12145 + 9531)
6027/(6027+4064+2147+1313)
(6027 + 2147)/(6027+4064+2147+1313)
(6027 + 4064)/(6027+4064+2147+1313)
0.7447 * 0.6032
(6027 + 4064)/(6027+4064+2147+1313) * (6027 + 2147)/(6027+4064+2147+1313)
6027 / (4064 + 6027)
0.05 / 0.059
x <- c(0, 5, 10, 20, 100)
p <- c(.2, .3, .4, .08, .02)
mu <- sum(x * p)
tab <- cbind(x, p, x * p, (x - mu) ^2, (x - mu) ^ 2 * p)
require('xtable')
xtable(tab, digits = 2)
mu
sum((x - mu) ^2)
sum((x - mu) ^ 2 * p)
0.4664 - 0.3997
0.4664 + 0.3997
0.4999 - 0.4251
0.3 * 0.7 * 781
sqrt(0.3 * 0.7 / 781)
1 - pnorm((0.25-0.3) / 0.17)
70 * 0.7 * 0.3
0.05 / sqrt( 0.3 * 0.7 / 70)
1 - pnorm(0.05 / sqrt( 0.3 * 0.7 / 70))
1 - pnorm(-0.02 / sqrt( 0.3 * 0.7 / 70))
150 * 0.46 * 0.54
1 - pnorm(0.04 / sqrt( 0.46 * 0.54 / 150))
38550 * 4
38550 * 5
38550 * 4
ff <- function(u) - log(1-u)
ff(0.5)
ff(0.2)
p <- 54 / 143
q <- 1 - p
n <- 143
n * p * q
9 / 32
12 / 32
160 * 1.05
16 * 1.5
24 + 56
24 * 1.5
36 + 56
25 * 1.5
2050 / 2000
41 * 1.5 + 1799 + 155
41 * 1.5 + 57
35 * 1.3
d = 3
-1/(2* ( d + 2))
-1/(2* ( d + 2)) * (-2) - 1/2
-1/(2* ( d + 2)) * (d + 1)
x <- c(1, 2, 3)
y <- c(13, 10, 12)
cor.test(x, y, method = 'kendall')
y2 <- c(3, 8, 9)
cor.test(x, y2, method = 'kendall')
0.95 ^ 15
install.packages('tigris')
require('tigris')
tracts("AL", "Autauga", cb = TRUE)
2700 * 0.07
2700 * 1.17
74.58 / 60.92
78.57 / 61.83
147.77 / 111.88
159.41 / 114.73
options(rgl.useNULL = TRUE)
# load package
library('this.path')
library('mgcv')
library('MGLM')
library('BPST')
library('cmna')
library('LaplacesDemon')
library('Rcpp')
library('RcppArmadillo')
library('fastmatrix')
library('quantreg')
library('MultiRNG')
# working directory
setwd(this.path::here())
## load functions
source('G.u.R')
source('ell.uh.R')
source('x1.R')
source('beta1.R')
source('tune.lambda.R')
source('tune.lambda.qsvcm.R')
source('SQBiT.R')
source('tpqr.plm.R')
source('AInv.R')
source('rG.R')
source('smqsvcm_admm.wb.R')
source('QBiT.R')
source('stoper.R')
source('rhotau.R')
source('SQBiT_tune.R')
source('cv.pred.SQBiT.R')
# c++ matrix inversion
Rcpp::cppFunction("arma::mat armaInv(const arma::mat & x) { return arma::inv(x); }",
depends = "RcppArmadillo")
# c++ matrix multiplication
sourceCpp('test.cpp')
# population
pop.all <- as.matrix(read.csv('horse_tr1_n5K.csv', header = TRUE))
pop.all <- pop.all[, -1]
S <- pop.all[, c(1, 2)]
S <- as.matrix(as.data.frame(S))
# triangulation matrix
# nrow is the number of triangles
# each row is the indices of vertices
#### Triangulation
Tr <- as.matrix(read.csv('Tr_1.csv', header = FALSE))     ########### change Tr_2.csv for Triangulation 2
# vertices of triangulation
V <- as.matrix(read.csv('V_1.csv', header = FALSE))       ########### change V_2.csv for Triangulation 2
# population
N.all <- nrow(pop.all)
# V0: vertices of a triangulation
# determine a point with (xx, yy) is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S[, 1], yy = S[, 2])
# indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(pop.all))[!is.na(pop.all[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- pop.all[ind, ]# sample size
Npop <- nrow(pop.r)
# coordinates
S.pop <- round(pop.r[, c(1, 2)], 2)
# unique covariates
u <- unique(round(pop.all[, 1], 2))
v <- unique(round(pop.all[, 2], 2))
pop.r <- cbind(pop.r, beta1(S.pop[, 1], S.pop[, 2]))
# Population basis
d <- 3
r <- 1
# bivariate spline basis function
# d = degree of piecewise polynomials
# r = smoothness parameters
# 0 <= r < d
# z = coordinates
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = S.pop)
# matrix after QR decomposition of the smoothness matrix
Q2 <- B0.pop$Q2
B.pop <- B0.pop$B # new basis
BQ2.pop <- as.matrix(B.pop %*% Q2)
# thin-plate energy function
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
# simulation
n <- 2500                               ########### change n = 1000 for n = 1000
nsim <- 200
set.seed(123)
seeds <- sample(1:1000, nsim)
tau <- 0.5                              ########### change tau = 0.75 for tau = 0.75
# set a seed
set.seed(123)
# simulating C
eta <- matrix(c(1, 1, 1))
# covariates
Sigma <- matrix(0, 3, 3)
for (i in 1:3) {
for (j in 1:3) {
Sigma[i, j] <- 0.5 ^ (abs(i - j))
}
}
# quantile
Finv <- qt(tau, df = 2)
colnames(pop.r) <- c('u', 'v', 'b0', 'b1')
# bandwidth
h <- 7 * tau * (1 - tau) * ((3 + dim(Q2)[2] * 2 + log(n)) / n) ^ (2/5)
## population varying coefficient
BQ2.pop <- as.matrix(B.pop %*% Q2)
beta.pop <- pop.r[, c('b0', 'b1')]
beta.pop[, 1] <- beta.pop[, 1] + Finv
beta.pop[, 2] <- beta.pop[, 2]
## coverage for VC
all_all_Beta2 <- c()
## coverage for constant
covs1 <- c()
lengths1 <- c()
covs2 <- c()
lengths2 <- c()
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
beta0 <- data[, c('b0', 'b1')]
# locations
S <- data[, c(1, 2)]
# constant covariates
C <- draw.d.variate.uniform(no.row = n,
d = 3,
cov.mat = Sigma) * sqrt(3)
C <- C - 0.5 * sqrt(3)
X <- runif(n, -1, 1)
Y <- beta0[, 1] + X * beta0[, 2] + C %*% eta + rt(n = n, 2)
X <- cbind(1, X)
# generate Bivariate spline basis
B <- B.pop[ind.s, ]
# alpha
true.alpha.samp <- beta0
true.alpha.samp[, 1] <- true.alpha.samp[, 1] + Finv
true.alpha.samp[, 2] <- true.alpha.samp[, 2]
####### tuning for SQBiT (5-fold CV)
lambda_SQBiT <- SQBiT_tune(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
h = h, tau = tau,
lambda_start = 1e-4, lambda_end = 1e1,
nlambda = 10, new.nlambda = 10,
lambda.scale = 100)
###### Point Estimation
mod_SQBiT <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2, tau = tau,
lambda = lambda_SQBiT$lambda, h = h, adaptive.h = FALSE,
gacv.compute = FALSE, interval = TRUE)
##### asymptotic interval
cis1 <- mod_SQBiT$cis
##### wild bootstrap
mod_SQBiT.wb <- smqsvcm_admm.wb(h = h, tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2,
eta.j = .32, var.j = FALSE, biascorr = TRUE,
lambda = mod_SQBiT$lambdac, Br = 500,
compute.vc = TRUE, BQ2.eva = BQ2.pop,
gamma.hat = mod_SQBiT$gamma)
mod_SQBiT$lambdac
##### wild bootstrap
mod_SQBiT.wb <- smqsvcm_admm.wb(h = h, tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2,
eta.j = .32, var.j = FALSE, biascorr = TRUE,
lambda = mod_SQBiT$lambda, Br = 500,
compute.vc = TRUE, BQ2.eva = BQ2.pop,
gamma.hat = mod_SQBiT$gamma)
##### wild bootstrap
mod_SQBiT.wb <- smqsvcm_admm.wb(h = h, tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2,
eta.j = .32, var.j = FALSE, biascorr = TRUE,
lambda = lambda_SQBiT$lambda, Br = 500,
compute.vc = TRUE, BQ2.eva = BQ2.pop,
gamma.hat = mod_SQBiT$gamma)
cis2 <- mod_SQBiT.wb$cis
cis2
mod_SQBiT$gamma
length(mod_SQBiT$gamma)
##### wild bootstrap
mod_SQBiT.wb <- smqsvcm_admm.wb(h = h, tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2,
eta.j = .32, var.j = FALSE, biascorr = TRUE,
lambda = lambda_SQBiT$lambda, Br = 500,
compute.vc = TRUE, BQ2.eva = BQ2.pop,
gamma.hat = c(mod_SQBiT$eta, mod_SQBiT$gamma))
cis2 <- mod_SQBiT.wb$cis
cis2
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
beta0 <- data[, c('b0', 'b1')]
# locations
S <- data[, c(1, 2)]
# constant covariates
C <- draw.d.variate.uniform(no.row = n,
d = 3,
cov.mat = Sigma) * sqrt(3)
C <- C - 0.5 * sqrt(3)
X <- runif(n, -1, 1)
Y <- beta0[, 1] + X * beta0[, 2] + C %*% eta + rt(n = n, 2)
X <- cbind(1, X)
# generate Bivariate spline basis
B <- B.pop[ind.s, ]
# alpha
true.alpha.samp <- beta0
true.alpha.samp[, 1] <- true.alpha.samp[, 1] + Finv
true.alpha.samp[, 2] <- true.alpha.samp[, 2]
##### GACV
mod_SQBiT <- tune.lambda(Y = Y, X = X, C = C, max.iter = 100,
P = P, B = B, Q2 = Q2, var.j.2 = FALSE,
h = h, tau = tau, lambda_start = 1e-4, zeta = 14,
eta.j1 = .32, eta.j2 = .32, nlambda = 10, new.nlambda = 10,
lambda.scale = 100, interval = TRUE, kernel = 'unif')
cis1 <- mod_SQBiT$cis2
##### wild bootstrap
mod_SQBiT.wb <- smqsvcm_admm.wb(h = h, tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2,
eta.j = .32, var.j = FALSE, biascorr = TRUE,
lambda = mod_SQBiT$lambdac, Br = 500,
compute.vc = TRUE, BQ2.eva = BQ2.pop,
gamma.hat = mod_SQBiT$gamma)
cis2 <- mod_SQBiT.wb$cis
cis2
options(rgl.useNULL = TRUE)
# load package
library('this.path')
library('mgcv')
library('MGLM')
library('BPST')
library('cmna')
library('LaplacesDemon')
library('Rcpp')
library('RcppArmadillo')
library('fastmatrix')
library('quantreg')
library('MultiRNG')
# working directory
setwd(this.path::here())
## load functions
source('G.u.R')
source('ell.uh.R')
source('x1.R')
source('beta1.R')
source('tune.lambda.R')
source('tune.lambda.qsvcm.R')
source('SQBiT.R')
source('tpqr.plm.R')
source('AInv.R')
source('rG.R')
source('smqsvcm_admm.wb.R')
source('QBiT.R')
source('stoper.R')
source('rhotau.R')
source('SQBiT_tune.R')
source('cv.pred.SQBiT.R')
# c++ matrix inversion
Rcpp::cppFunction("arma::mat armaInv(const arma::mat & x) { return arma::inv(x); }",
depends = "RcppArmadillo")
# c++ matrix multiplication
sourceCpp('test.cpp')
# population
pop.all <- as.matrix(read.csv('horse_tr1_n5K.csv', header = TRUE))
pop.all <- pop.all[, -1]
S <- pop.all[, c(1, 2)]
S <- as.matrix(as.data.frame(S))
# triangulation matrix
# nrow is the number of triangles
# each row is the indices of vertices
#### Triangulation
Tr <- as.matrix(read.csv('Tr_1.csv', header = FALSE))     ########### change Tr_2.csv for Triangulation 2
# vertices of triangulation
V <- as.matrix(read.csv('V_1.csv', header = FALSE))       ########### change V_2.csv for Triangulation 2
# population
N.all <- nrow(pop.all)
# V0: vertices of a triangulation
# determine a point with (xx, yy) is inside a given triangulation
ind1 <- inVT(V0 = V, Tr0 = Tr,
xx = S[, 1], yy = S[, 2])
# indices of all the points which are inside the triangulation
ind1 <- ind1$ind.inside
ind2 <- (1:nrow(pop.all))[!is.na(pop.all[, 1])]
ind <- sort(intersect(ind1, ind2))
pop.r <- pop.all[ind, ]# sample size
Npop <- nrow(pop.r)
# coordinates
S.pop <- round(pop.r[, c(1, 2)], 2)
# unique covariates
u <- unique(round(pop.all[, 1], 2))
v <- unique(round(pop.all[, 2], 2))
pop.r <- cbind(pop.r, beta1(S.pop[, 1], S.pop[, 2]))
# Population basis
d <- 3
r <- 1
# bivariate spline basis function
# d = degree of piecewise polynomials
# r = smoothness parameters
# 0 <= r < d
# z = coordinates
B0.pop <- basis(V = V, Tr = Tr,
d = d, r = r,
Z = S.pop)
# matrix after QR decomposition of the smoothness matrix
Q2 <- B0.pop$Q2
B.pop <- B0.pop$B # new basis
BQ2.pop <- as.matrix(B.pop %*% Q2)
# thin-plate energy function
K <- B0.pop$K
P <- t(Q2) %*% K %*% Q2
# simulation
n <- 1000                               ########### change n = 1000 for n = 1000
nsim <- 200
set.seed(123)
seeds <- sample(1:1000, nsim)
tau <- 0.5                              ########### change tau = 0.75 for tau = 0.75
# set a seed
set.seed(123)
# simulating Y
eta <- matrix(c(1, 1, 1))
# covariates
Sigma <- matrix(0, 3, 3)
for (i in 1:3) {
for (j in 1:3) {
Sigma[i, j] <- 0.5 ^ (abs(i - j))
}
}
# quantile
Finv <- qt(tau, df = 2)
colnames(pop.r) <- c('u', 'v', 'b0', 'b1')
ind.s <- sample(1:Npop, n)
data <- as.matrix(pop.r[ind.s, ])
beta0 <- data[, c('b0', 'b1')]
# locations
S <- data[, c(1, 2)]
# constant covariates
C <- draw.d.variate.uniform(no.row = n,
d = 3,
cov.mat = Sigma) * sqrt(3)
C <- C - 0.5 * sqrt(3)
X <- runif(n, -1, 1)
Y <- beta0[, 1] + X * beta0[, 2] + C %*% eta + (1 + .2 * C[, 3] + X * x1(S[, 'u'], S[, 'v'])) * rt(n = n, 2)
X <- cbind(1, X)
# generate Bivariate spline basis
B <- B.pop[ind.s, ]
# alpha
true.alpha.samp <- beta0
true.alpha.samp[, 1] <- true.alpha.samp[, 1] + Finv
true.alpha.samp[, 2] <- true.alpha.samp[, 2] + x1(S[, 'u'], S[, 'v']) * Finv
true.eta <- eta
true.eta[3] <- eta[3] + .2 * Finv
####### tuning for SQBiT (5-fold CV)
lambda_SQBiT <- SQBiT_tune(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2,
h = h, tau = tau,
lambda_start = 1e-4, lambda_end = 1e1,
nlambda = 10, new.nlambda = 10,
lambda.scale = 100)
###### Point Estimation
mod_SQBiT <- SQBiT(Y = Y, X = X, C = C,
P = P, B = B, Q2 = Q2, tau = tau,
lambda = lambda_SQBiT$lambda, h = h, adaptive.h = FALSE,
gacv.compute = FALSE, interval = TRUE)
##### asymptotic interval
cis1 <- mod_SQBiT$cis
##### wild bootstrap
mod_SQBiT.wb <- smqsvcm_admm.wb(h = h, tau = tau, Y = Y, C = C, X = X, P = P, B = B, Q2 = Q2,
eta.j = .32, var.j = FALSE, biascorr = TRUE,
lambda = lambda_SQBiT$lambda, Br = 500,
compute.vc = TRUE, BQ2.eva = BQ2.pop,
gamma.hat = c(mod_SQBiT$eta, mod_SQBiT$gamma))
cis2 <- mod_SQBiT.wb$cis
# varying coefficient
vc.lb <- mod_SQBiT.wb$betas.lb
vc.ub <- mod_SQBiT.wb$betas.ub
cis2
cis1
